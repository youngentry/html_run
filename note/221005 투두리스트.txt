1. target.value > event가 발생하면 state를 value로 바꿉니다.

>>> word useState를 만들고,
const [word, setWord] = useState("");
>>> setState에는 이벤트의 값을 주도록 합니다. (e.target.value)
<div><input type="text" onChange={(e) => setWord(e.target.value)} /></div>




2. value를 데이터에 저장합니다.

>>> list useState를 만들고, 여기에는 배열을 담을 것입니다.
    const [list, setList] = useState([]);
            <button onClick={() => setList([word])}>저장하기</button>
        
            
            
            
3. 저장된 데이터를 먼저 뿌리고, 스프레드연산자를 이용해 새로운 데이터를 추가합니다.

>>> 배열을 스프레드 연산자로 펼치고, word을 뒤에 적어주면 됩니다.
            <button onClick={() => setList([...list, word])}>저장하기</button>





4. 객체와 name을 써서 입력 여러개를 동시에 할 수 있도록 합니다.

>>> word state의 기본값을 객체{}로 합니다.
    const [word, setWord] = useState({});
    
>>> 객체의 키와 값을 전달합니다.
                <input type="text" onChange={(e) => setWord({ [e.target.name]: e.target.value })} name="content" />
                
>>> 마찬가지로 저장된 데이터를 뿌리고, 새로운 데이터를 추가합니다.
                <input type="text" onChange={(e) => setWord({ ...word, [e.target.name]: e.target.value })} name="title" />
                <input type="text" onChange={(e) => setWord({ ...word, [e.target.name]: e.target.value })} name="content" />


5. 같은 기능을 가진 onChange이벤트를 하나의 함수로 만듭니다.
>>> handleWord 함수를 만들어서 e를 전달하고 동일한 기능을 하도록 setWord({ ...word, [e.target.name]: e.target.value }) 를 수행합니다.
    const handleWord = (e) => {
        setWord({ ...word, [e.target.name]: e.target.value });
    };
>>> onChange 이벤트에 {handleWord} 함수를 전달합니다.
                <input type="text" onChange={handleWord} name="title" />

>>> ??? 객체로 비구조할당되는 원리
    const handleWord = (e) => {
        const { name, value } = e.target;
        setWord({ ...word, [name]: value, id: num.current });
    };

>>> 마찬가지로 handleList 함수도 만들어줍니다.
    const handleList = () => {
        setList([...list, word]);
    };
                <button onClick={handleList}>저장하기</button>


6. 각 객체가 고유한 id를 가져 삭제와 수정을 할 수 있도록 합니다.
>>> useRef를 변수로 객체가 추가될 때마다 id에 1을 더해 추가하도록 합니다.
        setWord({ ...word, [name]: value, id: num.current });
>>> 객체가 리스트에 추가되고 나면 num.current++로 다음 값은 id가 1늘어나도록 합니다.
    const handleList = () => {
        setList([...list, word]);
        num.current++;
    };


7. 저장을 하고나서는 입력창을 비우도록 합니다.
    const handleList = () => {
        setList([...list, word]);
        setWord({
            title: "",
            content: "",
        });
        num.current++;
    };
>>> 하지만 이는 리액트의 제어 컴포넌트방식에 어긋납니다.
>>> 비제어 컴포넌트 방식이 아닌 리액트의 제어 컴포넌트방식에 맞도록 디폴트 값을 정해줘야 합니다.
    const [word, setWord] = useState({
        title: "",
        content: "",
    });
알아가기 제어 컴포넌트, 비제어 컴포넌트
https://dori-coding.tistory.com/entry/React-%EC%A0%9C%EC%96%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8Controlled-Component%EC%99%80-%EB%B9%84%EC%A0%9C%EC%96%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8Uncontrolled-Component


8. 입력창을 포커스합니다.
>>> useRef로 input을 선택합니다.
    const inputTitle = useRef();
>>> useRef를 전달합니다.
                <input type="text" onChange={handleWord} name="title" value={word.title} ref={inputTitle} />
>>> inputTitle.current.focus();로 focus를 합니다.
    const handleList = () => {
        if (word.title.length < 2) {
            alert("더입력해주세요");
            // 1. 입력창을 비운다. 2. 입력창을 포커싱한다.
            setWord({
>>> 여기서도 ...word로 제어컴포넌트 방식에 맞게 합니다.
                ...word,
                title: "",
            });
            inputTitle.current.focus();
            return;


>>> +정규식으로 한글만을 입력하도록 할 수 있습니다. .test()메서드로 true, false를 반환합니다.
        const hg = /^[ㄱ-ㅎ가-힣]*$/;
        if (!hg.test(word.title)) {
        
        
9. 파일을 컴포넌트화하기 위해서 props를 전달합니다.
            <TodoList list={list} />
            <TodoWrite list={list} word={word} handleWord={handleWord} handleList={handleList} inputTitle={inputTitle} inputContent={inputContent} />
>>> html로 만듭니다.
const TodoWrite = ({ list, word, handleWord, handleList, inputTitle, inputContent }) => {
    return (
        <div>
            <div>
                <input type="text" onChange={handleWord} name="title" value={word.title} ref={inputTitle} />
            </div>
            <div>
                <input type="text" onChange={handleWord} name="content" value={word.content} ref={inputContent} />
            </div>
            <div>
                <button onClick={handleList}>저장하기</button>
            </div>
        </div>
    );
};


const TodoList = ({ list }) => {
    return (
        <div>
            <h2>list</h2>
            <ul>
                {list.map((li, idx) => (
                    <li key={idx}>
                        {li.id}
                        {li.title} {li.content} <buttton>삭제</buttton>
                    </li>
                ))}
            </ul>
        </div>
    );
};


10. 삭제하기 버튼을 만들어 id가 일치하는 목록을 삭제합니다.
>>> List 수정을 하기 위해서 setList를 props로 넘겨줍니다.
                <Route path="/" element={<TodoList list={list} setList={setList}/>} />

>>> handleRemove 함수를 만듭니다. 
                        {li.title} {li.content} <button onClick={() => handleRemove(li.id)}>삭제</button>
>>> handleRemove 함수는 list 중에서 같은 id를 가진 리스트를 삭제합니다. 
>>> 받아온 setList에 filter함수로 id가 일치하지 않는 것만을 골라냅니다.
const TodoList = ({ list, setList }) => {
    const handleRemove = (id) => {
        setList(list.filter((it) => id !== it.id));
    };    
    
    
    
    
    
    
    
    
const TodoList = ({ list }) => {
    // 비구조할당으로 아래와 같습니다.
    // const TodoList = (props) => {
    //     const { list } = props;